/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst } from 'workbox-strategies';
import { OpenOfflineStore, OutboxEntry } from './offlineStore';

declare let self: ServiceWorkerGlobalScope;

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Minimum delay between retry attempts (5 seconds)
const MIN_RETRY_DELAY_MS = 5000;

// Listen for skip waiting message from the client
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  } else if (event.data && event.data.type === 'MANUAL_SYNC') {
    // Manual sync triggered by user action (fallback for when background sync doesn't work)
    event.waitUntil(syncPendingScores());
  }
});

// Take control of all clients when activated
self.addEventListener('activate', () => {
  self.clients.claim();
});

// Network-first for API calls
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
  })
);

// Handle background sync for score updates
self.addEventListener('sync', (event: SyncEvent) => {
  if (event.tag === 'sync-scores') {
    event.waitUntil(syncPendingScores());
  }
});

async function syncPendingScores(): Promise<void> {
  const store = await OpenOfflineStore();
  const pending = await store.getPendingForSyncNow();

  if (pending.length === 0) {
    return;
  }

  // Get CSRF token from session request
  let csrfToken: string | null = null;
  try {
    const sessionResponse = await fetch('/api/admin/session', {
      credentials: 'same-origin',
    });
    if (sessionResponse.ok) {
      const session = await sessionResponse.json();
      csrfToken = session.csrfToken;
    } else if (sessionResponse.status === 401 || sessionResponse.status === 403) {
      // Session expired or unauthorized - notify user to re-authenticate
      // Keep pending updates in queue for retry after re-login
      const clients = await self.clients.matchAll();
      clients.forEach(client => {
        client.postMessage({
          type: 'SYNC_AUTH_REQUIRED',
          error: 'Session expired. Please log in again to sync your changes.',
        });
      });
      // Return without throwing - updates stay in queue
      return;
    }
  } catch {
    // Will retry on next sync
    throw new Error('Failed to get CSRF token');
  }

  if (!csrfToken) {
    throw new Error('No CSRF token available');
  }

  // Group entries by section
  const batchesBySection = new Map<string, OutboxEntry[]>();
  for (const entry of pending) {
    const existing = batchesBySection.get(entry.sectionId) || [];
    existing.push(entry);
    batchesBySection.set(entry.sectionId, existing);
  }

  // Process each section's pending scores
  for (const [sectionId, entries] of batchesBySection) {
    try {
      // Build updates array
      const updates = entries.map(e => ({
        patrolId: e.patrolId,
        points: e.scoreDelta,
      }));

      const response = await fetch(`/api/admin/sections/${sectionId}/scores`, {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken,
        },
        body: JSON.stringify({ updates }),
      });

      if (response.ok) {
        // Parse response to get per-patrol results
        const responseData = await response.json();
        const patrols = responseData.patrols as PatrolResult[];

        // Process each patrol result
        for (const patrol of patrols) {
          if (patrol.success) {
            // Success - clear the entry
            await store.clear(sectionId, patrol.id);
          } else if (patrol.isTemporaryError && patrol.retryAfter) {
            // Temporary error - set retryAfter with error message
            const retryAfterDate = new Date(patrol.retryAfter);
            const errorMsg = patrol.error || 'Temporary error, will retry';
            await store.setRetryAfter(sectionId, patrol.id, retryAfterDate, errorMsg);
          } else {
            // Permanent error - mark as failed (client will need to acknowledge)
            const errorMsg = patrol.error || 'Update failed';
            await store.setError(sectionId, patrol.id, errorMsg);
          }
        }

        // Notify the client with patrol data
        const hasPermanentErrors = patrols.some(p => !p.success && !p.isTemporaryError);
        const clients = await self.clients.matchAll();
        clients.forEach(client => {
          client.postMessage({
            type: 'SYNC_SUCCESS',
            sectionId: sectionId,
            patrols: patrols,
            hasPermanentErrors: hasPermanentErrors, // Signal client to check failed entries
          });
        });
      } else if (response.status === 401 || response.status === 403) {
        // Auth error - keep in queue, notify user
        const clients = await self.clients.matchAll();
        clients.forEach(client => {
          client.postMessage({
            type: 'SYNC_AUTH_REQUIRED',
            sectionId: sectionId,
            error: 'Session expired. Please log in again to sync your changes.',
          });
        });
        // Stop processing further batches - they'll all fail with same auth error
        return;
      } else if (response.status >= 400 && response.status < 500) {
        // Other client error (400 Bad Request, etc.) - mark as permanent errors
        const errorMsg = `Server rejected update: ${response.status}`;
        for (const entry of entries) {
          await store.setError(sectionId, entry.patrolId, errorMsg);
        }

        const clients = await self.clients.matchAll();
        clients.forEach(client => {
          client.postMessage({
            type: 'SYNC_ERROR',
            sectionId: sectionId,
            error: errorMsg,
          });
        });
      } else {
        // 5xx error - set retryAfter for all entries in this batch
        const retryAfter = new Date(Date.now() + MIN_RETRY_DELAY_MS);
        const errorMsg = `Server error: ${response.status}`;
        for (const entry of entries) {
          await store.setRetryAfter(sectionId, entry.patrolId, retryAfter, errorMsg);
        }
        // Continue to next batch (maybe other sections will succeed)
      }
    } catch (err) {
      // Network error - set retryAfter for all entries in this batch
      const retryAfter = new Date(Date.now() + MIN_RETRY_DELAY_MS);
      const errorMsg = err instanceof Error ? err.message : 'Network error';
      for (const entry of entries) {
        await store.setRetryAfter(sectionId, entry.patrolId, retryAfter, errorMsg);
      }
      // Continue to next batch
    }
  }

  // Schedule next sync if there are entries that need retry
  await scheduleNextSync(store);
}

async function scheduleNextSync(store: Awaited<ReturnType<typeof OpenOfflineStore>>): Promise<void> {
  const soonestRetry = await store.getSoonestRetryAfter();
  if (soonestRetry === null) {
    // No pending entries, nothing to schedule
    return;
  }

  const now = Date.now();
  const delayMs = Math.max(soonestRetry - now, MIN_RETRY_DELAY_MS);

  // Use setTimeout to trigger another sync attempt
  // Note: This only works while the service worker stays active
  // For proper background sync, we'd use the Background Sync API
  setTimeout(() => {
    syncPendingScores().catch(err => {
      console.error('Scheduled sync failed:', err);
    });
  }, delayMs);
}

// TypeScript types
interface PatrolResult {
  id: string;
  name: string;
  success: boolean;
  isTemporaryError?: boolean;
  retryAfter?: string;
  error?: string;
  previousScore?: number;
  newScore?: number;
}

interface SyncEvent extends ExtendableEvent {
  tag: string;
}

declare global {
  interface ServiceWorkerGlobalScope {
    addEventListener(type: 'sync', listener: (event: SyncEvent) => void): void;
  }
}
