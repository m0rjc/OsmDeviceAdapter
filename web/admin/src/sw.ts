/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst } from 'workbox-strategies';

declare let self: ServiceWorkerGlobalScope;

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Listen for skip waiting message from the client
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Take control of all clients when activated
self.addEventListener('activate', () => {
  self.clients.claim();
});

// Network-first for API calls
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
  })
);

// Handle background sync for score updates
self.addEventListener('sync', (event: SyncEvent) => {
  if (event.tag === 'sync-scores') {
    event.waitUntil(syncPendingScores());
  }
});

async function syncPendingScores(): Promise<void> {
  const db = await openDB();
  const pending = await getAllPending(db);

  if (pending.length === 0) {
    return;
  }

  // Consolidate all pending updates by section and patrol
  // This ensures we only send the net change, reducing API calls
  // and avoiding issues with rapid conflicting updates
  const consolidatedBySection = new Map<number, Map<string, number>>();
  const updateIdsBySection = new Map<number, number[]>();

  for (const update of pending) {
    // Track which update IDs belong to each section
    const ids = updateIdsBySection.get(update.sectionId) || [];
    ids.push(update.id);
    updateIdsBySection.set(update.sectionId, ids);

    // Sum points per patrol
    let patrolPoints = consolidatedBySection.get(update.sectionId);
    if (!patrolPoints) {
      patrolPoints = new Map<string, number>();
      consolidatedBySection.set(update.sectionId, patrolPoints);
    }

    for (const scoreUpdate of update.updates) {
      const current = patrolPoints.get(scoreUpdate.patrolId) || 0;
      patrolPoints.set(scoreUpdate.patrolId, current + scoreUpdate.points);
    }
  }

  // Filter out patrols with net-zero changes and build final updates per section
  const sectionsToSync: Array<{
    sectionId: number;
    updates: Array<{ patrolId: string; points: number }>;
    originalIds: number[];
  }> = [];

  for (const [sectionId, patrolPoints] of consolidatedBySection) {
    const nonZeroUpdates: Array<{ patrolId: string; points: number }> = [];
    for (const [patrolId, points] of patrolPoints) {
      if (points !== 0) {
        nonZeroUpdates.push({ patrolId, points });
      }
    }

    sectionsToSync.push({
      sectionId,
      updates: nonZeroUpdates,
      originalIds: updateIdsBySection.get(sectionId) || [],
    });
  }

  // Get CSRF token from a session request
  let csrfToken: string | null = null;
  try {
    const sessionResponse = await fetch('/api/admin/session', {
      credentials: 'same-origin',
    });
    if (sessionResponse.ok) {
      const session = await sessionResponse.json();
      csrfToken = session.csrfToken;
    } else if (sessionResponse.status === 401 || sessionResponse.status === 403) {
      // Session expired or unauthorized - notify user to re-authenticate
      // Keep pending updates in queue for retry after re-login
      const clients = await self.clients.matchAll();
      clients.forEach(client => {
        client.postMessage({
          type: 'SYNC_AUTH_REQUIRED',
          error: 'Session expired. Please log in again to sync your changes.',
        });
      });
      // Return without throwing - updates stay in queue
      return;
    }
  } catch {
    // Will retry on next sync
    throw new Error('Failed to get CSRF token');
  }

  if (!csrfToken) {
    throw new Error('No CSRF token available');
  }

  // Process each section's consolidated update
  for (const section of sectionsToSync) {
    try {
      // If all changes netted to zero, just clear the queue entries
      if (section.updates.length === 0) {
        for (const id of section.originalIds) {
          await removePending(db, id);
        }
        // We do not notify the client that sync is done as the user will not expect it. (No indication of sync
        // pending in the UI in this case)
        // const clients = await self.clients.matchAll();
        // clients.forEach(client => {
        //   client.postMessage({
        //     type: 'SYNC_SUCCESS',
        //     sectionId: section.sectionId,
        //   });
        // });
        continue;
      }

      const response = await fetch(`/api/admin/sections/${section.sectionId}/scores`, {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken,
        },
        body: JSON.stringify({ updates: section.updates }),
      });

      if (response.ok) {
        // Remove all original entries from queue on success
        //
        // TODO: There is a small risk that the change may have been applied to OSM but the request subsequently failed.
        // We'd end up resubmitting then. We may have to move towards attempting recovery server side or having
        // this app as the source of truth with delayed sync to OSM.
        for (const id of section.originalIds) {
          await removePending(db, id);
        }

        // Notify the client
        const clients = await self.clients.matchAll();
        clients.forEach(client => {
          client.postMessage({
            type: 'SYNC_SUCCESS',
            sectionId: section.sectionId,
          });
        });
      } else if (response.status === 401 || response.status === 403) {
        // Auth error - keep updates in queue for retry after re-login
        const clients = await self.clients.matchAll();
        clients.forEach(client => {
          client.postMessage({
            type: 'SYNC_AUTH_REQUIRED',
            sectionId: section.sectionId,
            error: 'Session expired. Please log in again to sync your changes.',
          });
        });
        // Stop processing further sections - they'll all fail with same auth error
        return;
      } else if (response.status >= 400 && response.status < 500) {
        // Other client error (400 Bad Request, 404 Not Found, etc.) - don't retry, remove from queue
        // These are genuine client errors that won't be fixed by retrying
        for (const id of section.originalIds) {
          await removePending(db, id);
        }

        const clients = await self.clients.matchAll();
        clients.forEach(client => {
          client.postMessage({
            type: 'SYNC_ERROR',
            sectionId: section.sectionId,
            error: `Server rejected update: ${response.status}`,
          });
        });
      }
      // 5xx errors will cause the sync to be retried
    } catch {
      // Network error - will retry on next sync
      throw new Error('Network error during sync');
    }
  }
}

// IndexedDB helpers for service worker
const DB_NAME = 'penguin-patrol-scores';
const STORE_NAME = 'pending-updates';

interface PendingUpdate {
  id: number;
  sectionId: number;
  updates: Array<{ patrolId: string; points: number }>;
  createdAt: number;
}

function openDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

function getAllPending(db: IDBDatabase): Promise<PendingUpdate[]> {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    const request = store.getAll();
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

function removePending(db: IDBDatabase, id: number): Promise<void> {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const request = store.delete(id);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve();
  });
}

// TypeScript types for Sync API
interface SyncEvent extends ExtendableEvent {
  tag: string;
}

declare global {
  interface ServiceWorkerGlobalScope {
    addEventListener(type: 'sync', listener: (event: SyncEvent) => void): void;
  }
}
