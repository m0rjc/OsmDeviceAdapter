/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst } from 'workbox-strategies';

declare let self: ServiceWorkerGlobalScope;

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Listen for skip waiting message from the client
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  } else if (event.data && event.data.type === 'MANUAL_SYNC') {
    // Manual sync triggered by user action (fallback for when background sync doesn't work)
    event.waitUntil(syncPendingScores());
  }
});

// Take control of all clients when activated
self.addEventListener('activate', () => {
  self.clients.claim();
});

// Network-first for API calls
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
  })
);

// Handle background sync for score updates
self.addEventListener('sync', (event: SyncEvent) => {
  if (event.tag === 'sync-scores') {
    event.waitUntil(syncPendingScores());
  }
});

async function syncPendingScores(): Promise<void> {
  const db = await openDB();
  const pending = await getPendingOutboxEntries(db);

  if (pending.length === 0) {
    return;
  }

  // Get CSRF token from session request
  let csrfToken: string | null = null;
  try {
    const sessionResponse = await fetch('/api/admin/session', {
      credentials: 'same-origin',
    });
    if (sessionResponse.ok) {
      const session = await sessionResponse.json();
      csrfToken = session.csrfToken;
    } else if (sessionResponse.status === 401 || sessionResponse.status === 403) {
      // Session expired or unauthorized - notify user to re-authenticate
      // Keep pending updates in queue for retry after re-login
      const clients = await self.clients.matchAll();
      clients.forEach(client => {
        client.postMessage({
          type: 'SYNC_AUTH_REQUIRED',
          error: 'Session expired. Please log in again to sync your changes.',
        });
      });
      // Return without throwing - updates stay in queue
      return;
    }
  } catch {
    // Will retry on next sync
    throw new Error('Failed to get CSRF token');
  }

  if (!csrfToken) {
    throw new Error('No CSRF token available');
  }

  // Group entries by idempotency key (each key is one submission batch)
  const batchesByKey = new Map<string, ClientOutboxEntry[]>();
  for (const entry of pending) {
    const existing = batchesByKey.get(entry.idempotencyKey) || [];
    existing.push(entry);
    batchesByKey.set(entry.idempotencyKey, existing);
  }

  // Process each batch
  for (const [idempotencyKey, entries] of batchesByKey) {
    try {
      // Mark entries as syncing
      for (const entry of entries) {
        await markEntrySyncing(db, entry.id!);
      }

      const sectionId = entries[0].sectionId;

      // Build updates array
      const updates = entries.map(e => ({
        patrolId: e.patrolId,
        points: e.points,
      }));

      const response = await fetch(`/api/admin/sections/${sectionId}/scores`, {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken,
          'X-Idempotency-Key': idempotencyKey,
          'X-Sync-Mode': 'background', // Use background mode for service worker
        },
        body: JSON.stringify({ updates }),
      });

      if (response.ok) {
        // Success (200 OK or 202 Accepted) - delete from client outbox
        for (const entry of entries) {
          await deleteOutboxEntry(db, entry.id!);
        }

        // Parse response body to get patrol updates
        let patrols: any[] | undefined;
        try {
          const responseData = await response.json();
          patrols = responseData.patrols;
        } catch (err) {
          // If JSON parsing fails, continue without patrol data
          // Client will refresh from server instead
        }

        // Notify the client with patrol data
        const clients = await self.clients.matchAll();
        clients.forEach(client => {
          client.postMessage({
            type: 'SYNC_SUCCESS',
            sectionId: sectionId,
            patrols: patrols, // Include patrol data from server response
          });
        });
      } else if (response.status === 401 || response.status === 403) {
        // Auth error - reset to pending, keep in queue for retry after re-login
        for (const entry of entries) {
          await markEntryFailed(db, entry.id!, 'Authentication required');
        }

        const clients = await self.clients.matchAll();
        clients.forEach(client => {
          client.postMessage({
            type: 'SYNC_AUTH_REQUIRED',
            sectionId: sectionId,
            error: 'Session expired. Please log in again to sync your changes.',
          });
        });
        // Stop processing further batches - they'll all fail with same auth error
        return;
      } else if (response.status >= 400 && response.status < 500) {
        // Other client error (400 Bad Request, etc.) - don't retry, delete from queue
        for (const entry of entries) {
          await deleteOutboxEntry(db, entry.id!);
        }

        const clients = await self.clients.matchAll();
        clients.forEach(client => {
          client.postMessage({
            type: 'SYNC_ERROR',
            sectionId: sectionId,
            error: `Server rejected update: ${response.status}`,
          });
        });
      } else {
        // 5xx error - mark as failed, will retry on next sync
        for (const entry of entries) {
          await markEntryFailed(db, entry.id!, `Server error: ${response.status}`);
        }
        // Continue to next batch (maybe this one will succeed)
      }
    } catch (err) {
      // Network error - mark as failed, will retry on next sync
      for (const entry of entries) {
        if (entry.id) {
          await markEntryFailed(db, entry.id, 'Network error');
        }
      }
      // Continue to next batch
    }
  }
}

// IndexedDB helpers for service worker
const DB_NAME = 'penguin-patrol-scores';
const DB_VERSION = 2;
const CLIENT_OUTBOX_STORE = 'client-outbox';

interface ClientOutboxEntry {
  id?: number;
  idempotencyKey: string;
  sectionId: number;
  patrolId: string;
  points: number;
  status: 'pending' | 'syncing' | 'server-pending';
  createdAt: number;
  lastAttemptAt?: number;
  error?: string;
}

function openDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

function getPendingOutboxEntries(db: IDBDatabase): Promise<ClientOutboxEntry[]> {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(CLIENT_OUTBOX_STORE, 'readonly');
    const store = tx.objectStore(CLIENT_OUTBOX_STORE);
    const index = store.index('status');
    const request = index.getAll('pending');

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

function markEntrySyncing(db: IDBDatabase, id: number): Promise<void> {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(CLIENT_OUTBOX_STORE, 'readwrite');
    const store = tx.objectStore(CLIENT_OUTBOX_STORE);
    const getRequest = store.get(id);

    getRequest.onsuccess = () => {
      const entry = getRequest.result as ClientOutboxEntry;
      if (entry) {
        entry.status = 'syncing';
        entry.lastAttemptAt = Date.now();
        store.put(entry);
      }
    };

    getRequest.onerror = () => reject(getRequest.error);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

function markEntryFailed(db: IDBDatabase, id: number, error: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(CLIENT_OUTBOX_STORE, 'readwrite');
    const store = tx.objectStore(CLIENT_OUTBOX_STORE);
    const getRequest = store.get(id);

    getRequest.onsuccess = () => {
      const entry = getRequest.result as ClientOutboxEntry;
      if (entry) {
        entry.status = 'pending'; // Reset to pending for retry
        entry.error = error;
        entry.lastAttemptAt = Date.now();
        store.put(entry);
      }
    };

    getRequest.onerror = () => reject(getRequest.error);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

function deleteOutboxEntry(db: IDBDatabase, id: number): Promise<void> {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(CLIENT_OUTBOX_STORE, 'readwrite');
    const store = tx.objectStore(CLIENT_OUTBOX_STORE);
    const request = store.delete(id);

    request.onerror = () => reject(request.error);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

// TypeScript types for Sync API
interface SyncEvent extends ExtendableEvent {
  tag: string;
}

declare global {
  interface ServiceWorkerGlobalScope {
    addEventListener(type: 'sync', listener: (event: SyncEvent) => void): void;
  }
}
