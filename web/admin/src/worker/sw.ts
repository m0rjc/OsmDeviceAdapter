/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { NetworkFirst } from 'workbox-strategies';
import * as messages from '../types/messages'
import {NetworkError, OsmAdapterApiService} from "./server/server";
import * as clients from "./client";
import {OpenPatrolPointsStore, PatrolPointsStore, Patrol as StoredPatrol} from "./store/store";
import type {ScoreDelta} from "../types/model";
import {reduceError} from "../types/reduceError";

declare let self: ServiceWorkerGlobalScope;

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Take control of all clients when activated
self.addEventListener('activate', () => {
    self.clients.claim();
});

// Serve index.html for all navigation requests (SPA routing)
// Exclude server-side OAuth endpoints that must hit the Go backend
// In dev mode, the precache is empty, so we need to fetch index.html directly
const navigationHandler = async (options: any) => {
    try {
        // Try to get from precache first (works in production builds)
        return await createHandlerBoundToURL('index.html')(options);
    } catch (e) {
        // Precache not available (dev mode), fall through to fetch
    }

    // Fallback for dev mode: fetch index.html directly
    return fetch('/admin/');
};

const navigationRoute = new NavigationRoute(navigationHandler, {
    allowlist: [/^\/admin/],
    denylist: [
        /^\/admin\/login/,
        /^\/admin\/callback/,
        /^\/admin\/logout/,
    ],
});
registerRoute(navigationRoute);

// Network-first for API calls
registerRoute(
    ({ url }) => url.pathname.startsWith('/api/'),
    new NetworkFirst({
        cacheName: 'api-cache',
    })
);

/**
 * Listen for messages from clients.
 */
self.addEventListener('message', (event) => {
    // Handle vite-plugin-pwa skip waiting message for update flow
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
        return;
    }

    const client = event.source as Client;
    const message = event.data as messages.ClientMessage;
    switch (message.type) {
        case 'get-profile':
            getProfile(client, message.requestId);
            break;
        case 'refresh':
            refreshScores(client, message.requestId, message.userId, message.sectionId);
            break;
        case 'submit-scores':
            submitScores(client, message.requestId, message.userId, message.sectionId, message.deltas);
            break;
        case 'sync-now':
            syncNow(client, message.requestId, message.userId, message.sectionId);
            break;
        case 'force-sync':
            forceSync(client, message.requestId, message.userId, message.sectionId);
            break;
        default:
            const unrecognized = message as any;
            console.warn(`ServiceWorker: Unexpected message type ${unrecognized.type}`);
    }
});

/**
 * Get or create an authenticated API service instance.
 *
 * This function implements the CSRF token caching strategy:
 * 1. If userId is provided: try to load cached credentials from IndexedDB
 * 2. If no cached credentials or no userId: fetch session from server
 * 3. If session fetched successfully: persist to IndexedDB for future use
 *
 * @param userId - Expected user ID (optional for bootstrap)
 * @returns OsmAdapterApiService instance with authentication state
 */
async function getAuthenticatedService(userId?: number): Promise<OsmAdapterApiService> {
    // Try to get cached credentials if we have a userId
    if (userId) {
        try {
            const store = await OpenPatrolPointsStore(userId);
            try {
                const metadata = await store.getUserMetadata();
                if (metadata.csrfToken && metadata.userName) {
                    // Use cached credentials
                    console.debug(`[ServiceWorker] Using cached CSRF token for user ${userId}`);
                    return new OsmAdapterApiService(userId, metadata.userName, metadata.csrfToken);
                }
            } finally {
                store.close();
            }
        } catch (e) {
            console.warn(`[ServiceWorker] Failed to load cached credentials for user ${userId}, will fetch session`, e);
        }
    }

    // No cached credentials - fetch session from server
    console.debug(`[ServiceWorker] Fetching session from server`);
    const server = new OsmAdapterApiService();
    const session = await server.fetchSession();

    // If authenticated, persist the credentials for future use
    if (session.isAuthenticated && session.userId) {
        try {
            const store = await OpenPatrolPointsStore(session.userId);
            try {
                const csrfToken = server.getCsrfToken();
                if (csrfToken) {
                    await store.setUserMetadata(session.userName, csrfToken);
                    console.debug(`[ServiceWorker] Persisted CSRF token for user ${session.userId}`);
                }
            } finally {
                store.close();
            }
        } catch (e) {
            console.warn(`[ServiceWorker] Failed to persist credentials for user ${session.userId}`, e);
            // Non-fatal - we can still proceed with the session
        }
    }

    return server;
}

/**
 * Require the specified user to be logged in.
 * Sends message to client if not logged in or wrong user.
 *
 * @param client - The client to send error messages to
 * @param userId - Expected user ID
 * @param requestId - Optional correlation ID from the originating request
 * @returns Authenticated service instance, or null if authentication failed
 */
async function requireLoggedInUser(client: Client, userId: number, requestId?: string): Promise<OsmAdapterApiService | null> {
    try {
        const server = await getAuthenticatedService(userId);

        if (!server.isAuthenticated) {
            client.postMessage(messages.newAuthenticationRequiredMessage(server.getLoginUrl(), requestId));
            return null;
        }

        if (server.userId !== userId) {
            client.postMessage(messages.newWrongUserMessage(userId, server.userId!));
            // Clear the invalid cached credentials
            try {
                const store = await OpenPatrolPointsStore(userId);
                try {
                    await store.clearUserAuth();
                } finally {
                    store.close();
                }
            } catch (e) {
                console.warn(`[ServiceWorker] Failed to clear cached credentials for user ${userId}`, e);
            }
            return null;
        }

        return server;
    } catch (e) {
        // Network error or other failure - send auth required
        const loginUrl = new OsmAdapterApiService().getLoginUrl();
        client.postMessage(messages.newAuthenticationRequiredMessage(loginUrl, requestId));
        return null;
    }
}

/**
 * Fetch the user profile from the server and send it to the client.
 * If the user is logged in, then a UserProfileMessage is given.
 * If the user is logged out, then an AuthenticationRequiredMessage is given.
 *
 * All clients will receive a SectionListChangeMessage if the section list has
 * changed. This is published after the UserProfileMessage sent to the calling
 * client. The first client will expect both messages because its call will
 * initialize the section list for the first time. The section list is
 * stored in browser storage until explicitly cleared.
 *
 * @param client - The client requesting the profile
 * @param requestId - Correlation ID to match request with response
 */
export async function getProfile(client: Client, requestId: string) {
    try {
        // Bootstrap authentication - no userId hint available
        const server = await getAuthenticatedService();

        if (!server.isAuthenticated || !server.userId) {
            client.postMessage(messages.newAuthenticationRequiredMessage(server.getLoginUrl(), requestId));
            return;
        }

        const userId = server.userId;
        const userName = server.user?.name ?? '';
        const csrfToken = server.getCsrfToken() ?? undefined;

        const store = await OpenPatrolPointsStore(userId);
        try {
            const sections = await server.fetchSections();
            const { changed, sectionsListRevision, lastError, lastErrorTime } = await store.setCanonicalSectionList(sections);
            client.postMessage(messages.newUserProfileMessage(
                userId,
                userName,
                csrfToken,
                sections,
                sectionsListRevision,
                requestId,
                lastError,
                lastErrorTime
            ));
            if (changed) {
                await clients.sendMessage(messages.newSectionListChangeMessage(userId, sections, sectionsListRevision));
            }
        } catch (e) {
            // Store the error in user metadata and bump sections list revision
            const errorMessage = reduceError(e, "Unable to fetch section list from server.");
            const { sectionsListRevision, lastError, lastErrorTime } = await store.setProfileError(errorMessage);

            // Get cached sections (if any) and send with error state
            const sections = await store.getSections();
            client.postMessage(messages.newUserProfileMessage(
                userId,
                userName,
                csrfToken,
                sections,
                sectionsListRevision,
                requestId,
                lastError,
                lastErrorTime
            ));
        } finally {
            store.close();
        }
    } catch (e) {
        // Failed to authenticate - send auth required
        const loginUrl = new OsmAdapterApiService().getLoginUrl();
        client.postMessage(messages.newAuthenticationRequiredMessage(loginUrl, requestId));
    }
}

/**
 * Request to refresh the patrol scores from the server.
 * This can also be used to perform the initial load of scores when the UI switches section.
 *
 * The worker will respond asynchronously with a PatrolsChangeMessage (includes requestId).
 * If the server is unreachable, cached data is sent first (with requestId), followed by
 * a ServiceErrorMessage (with requestId) to indicate the refresh failed.
 *
 * If the user is not logged in, then AuthenticationRequiredMessage is given (with requestId).
 * If the wrong user is logged in, then WrongUserMessage is given.
 *
 * @param client - The client requesting the refresh
 * @param requestId - Correlation ID to match request with response
 * @param userId - Expected user ID
 * @param sectionId - Section ID to refresh
 */
export async function refreshScores(client: Client, requestId: string, userId: number, sectionId: number) {
    const server = await requireLoggedInUser(client, userId, requestId);
    if (!server) {
        return;
    }

    const store = await OpenPatrolPointsStore(userId);
    try {
        const scores = await server.fetchScores(sectionId);
        const { patrols, uiRevision, lastError, lastErrorTime } = await store.setCanonicalPatrolList(sectionId, scores);
        // Send successful response with requestId to the specific client (error state cleared)
        console.debug(`[ServiceWorker] Refreshing scores for section ${sectionId} succeeded`);
        await clients.sendScoresToClient(client, userId, sectionId, patrols, uiRevision, lastError, lastErrorTime, requestId);
    } catch (e) {
        // Store the error on the section record and bump its UI revision
        const errorMessage = reduceError(e, "Unable to refresh patrol scores from server.");
        await store.setSectionError(sectionId, errorMessage);

        // Get the cached data with the new error state and send it
        console.warn(`[ServiceWorker] Refreshing scores for section ${sectionId} failed. Trying cached data:`);
        const { patrols, uiRevision, lastError, lastErrorTime } = await store.getScoresForSection(sectionId);
        await clients.sendScoresToClient(client, userId, sectionId, patrols, uiRevision, lastError, lastErrorTime, requestId);
    } finally {
        store.close();
    }
}


/**
 * Add pending score changes to the store and trigger a sync.
 * This is called when the user makes changes in the UI.
 *
 * @param client - The client submitting the scores
 * @param requestId - Correlation ID to match request with response
 * @param userId - User ID
 * @param sectionId - Section ID
 * @param deltas - Score changes to apply
 */
export async function submitScores(client: Client, requestId: string, userId: number, sectionId: number, deltas: ScoreDelta[]) {
    const store: PatrolPointsStore = await OpenPatrolPointsStore(userId);
    try {
        // Add pending changes to the store.
        // This optimistic update ensures that user intent is saved even if they have lost
        // authentication. This allows the user to recover by logging in again.
        for (const delta of deltas) {
            await store.addPendingPoints(sectionId, delta.patrolId, delta.score);
        }

        // Publish the optimistic update immediately to all clients
        // Note: This is an unsolicited broadcast, so no requestId
        const { patrols, uiRevision, lastError, lastErrorTime } = await store.getScoresForSection(sectionId);
        await clients.publishScores(userId, sectionId, patrols, uiRevision, lastError, lastErrorTime);

        // Only perform the sync if the user is still logged in.
        // If the user is not logged in, then requireLoggedInUser will send a message to the client
        // requesting them to log in again.
        const server = await requireLoggedInUser(client, userId, requestId);
        if (!server) {
            return;
        }

        // Perform a sync process for this {user,section} to commit the changes to the server.
        if (!server.isOffline()) {
            await syncPendingScores(server, store, userId, sectionId);
        }
    } finally {
        store.close();
    }
}

/**
 * Sync all pending score changes for a {user,section} to the server.
 * The server and store must be tied to the same user.
 */
async function syncPendingScores(server: OsmAdapterApiService, store: PatrolPointsStore, userId: number, sectionId: number) {
    // Atomically acquire lock and get pending patrols
    let lockId: string | null = null;
    let hasChanges: boolean = false;
    try {
        const {lockId: acquiredLockId, pending} = await store.acquirePendingForSync(sectionId, 30000);
        lockId = acquiredLockId;

        if (pending.length === 0) {
            console.log(`[ServiceWorker] No pending scores to sync for section ${sectionId}`);
            return // via finally;
        }

        // Build the updates array from the pending patrols
        const updates = pending.map((patrol : StoredPatrol):ScoreDelta => ({
            patrolId: patrol.patrolId,
            score: patrol.pendingScoreDelta
        }));
        hasChanges = true;

        console.log(`[ServiceWorker] Syncing ${updates.length} pending scores for section ${sectionId}`);

        // Submit to server
        const serverResult = await server.updateScores(sectionId, updates);

        // Build a unit of work to process all results atomically
        const uow = store.newUnitOfWork();
        for (const patrol of serverResult) {
            if (patrol.success) {
                uow.setCommittedScore(sectionId, patrol.id, patrol.newScore, patrol.name);
                continue;
            }

            // Type narrow: patrol is now a failure result (use type assertion as workaround)
            const failedPatrol = patrol as any;
            if (failedPatrol.isTemporaryError && failedPatrol.retryAfter) {
                // Temporary error - schedule retry
                const retryDate = new Date(failedPatrol.retryAfter);
                uow.setRetryAfter(sectionId, failedPatrol.id, retryDate, failedPatrol.errorMessage);
            } else {
                // Permanent error - mark as failed
                uow.setError(sectionId, failedPatrol.id, failedPatrol.errorMessage || 'Update failed');
            }
        }
        await uow.commit();
    } catch (e: any) {
        // Catastrophic error (network failure, server error, etc.)
        if(e instanceof NetworkError) {
            // Network error - offline or connectivity issue
            // Don't mark as failed, just log and let retry logic handle it
            console.warn(`[ServiceWorker] Network error syncing scores for section ${sectionId}:`, e.cause);
            // Note: We still broadcast below to update timing, but no error messages are set
        } else {
            // Server error or other failure - mark all pending entries as failed
            await store.markAllPendingAsFailed(sectionId, e.message || 'Failed to sync scores');
            console.error(`[ServiceWorker] Error in syncPendingScores for section ${sectionId}:`, e);
        }
    } finally {
        // Always release the lock
        if (lockId) {
            await store.releaseSyncLock(sectionId, lockId);
        }

        // Update section sync timing (updates nextRetryTime for countdown display)
        await store.updateSectionSyncTiming(sectionId);

        // If we locked any patrols, broadcast the updated state to all clients
        // This includes: successful syncs, failed syncs, and timing updates (even for NetworkError)
        if (hasChanges) {
            const { patrols, uiRevision, lastError, lastErrorTime } = await store.getScoresForSection(sectionId);
            await clients.publishScores(userId, sectionId, patrols, uiRevision, lastError, lastErrorTime);
        }
    }
}

/** Client-side rate limit for force sync (5 seconds) */
const SYNC_RATE_LIMIT_MS = 5000;

/**
 * Sync pending scores now (respects retry timers and permanent errors).
 * Triggered by user clicking "Sync Now" button or automatic retry timer.
 *
 * @param client - The client requesting the sync
 * @param requestId - Correlation ID to match request with response
 * @param userId - User ID
 * @param sectionId - Section ID
 */
export async function syncNow(client: Client, requestId: string, userId: number, sectionId: number) {
    const store = await OpenPatrolPointsStore(userId);
    try {
        // Enforce client-side rate limit
        const sections = await store.getSections();
        const section = sections.find(s => s.id === sectionId);
        if (section && section.lastSyncAttempt > 0) {
            const timeSinceLastSync = Date.now() - section.lastSyncAttempt;
            if (timeSinceLastSync < SYNC_RATE_LIMIT_MS) {
                console.warn(`[ServiceWorker] Sync rate limited: ${timeSinceLastSync}ms since last attempt`);
                // Still broadcast current state
                const { patrols, uiRevision, lastError, lastErrorTime } = await store.getScoresForSection(sectionId);
                await clients.sendScoresToClient(client, userId, sectionId, patrols, uiRevision, lastError, lastErrorTime, requestId);
                return;
            }
        }

        // Try to acquire section sync lock
        const lockId = await store.acquireSectionSyncLock(sectionId, 60000);
        if (!lockId) {
            console.log(`[ServiceWorker] Section ${sectionId} sync already in progress`);
            // Broadcast current state showing sync in progress
            const { patrols, uiRevision, lastError, lastErrorTime } = await store.getScoresForSection(sectionId);
            await clients.sendScoresToClient(client, userId, sectionId, patrols, uiRevision, lastError, lastErrorTime, requestId);
            return;
        }

        try {
            // Check authentication
            const server = await requireLoggedInUser(client, userId, requestId);
            if (!server) {
                return;
            }

            // Perform sync using existing syncPendingScores logic
            if (!server.isOffline()) {
                await syncPendingScores(server, store, userId, sectionId);
            }
        } finally {
            // Always release section lock
            await store.releaseSectionSyncLock(sectionId, lockId);

            // Broadcast final state
            const { patrols, uiRevision, lastError, lastErrorTime } = await store.getScoresForSection(sectionId);
            await clients.publishScores(userId, sectionId, patrols, uiRevision, lastError, lastErrorTime);
        }
    } finally {
        store.close();
    }
}

/**
 * Force sync pending scores (clears permanent errors, preserves rate limits).
 * Triggered by user clicking "Force Sync" button after acknowledging warnings.
 *
 * @param client - The client requesting the force sync
 * @param requestId - Correlation ID to match request with response
 * @param userId - User ID
 * @param sectionId - Section ID
 */
export async function forceSync(client: Client, requestId: string, userId: number, sectionId: number) {
    const store = await OpenPatrolPointsStore(userId);
    try {
        // Enforce client-side rate limit
        const sections = await store.getSections();
        const section = sections.find(s => s.id === sectionId);
        if (section && section.lastSyncAttempt > 0) {
            const timeSinceLastSync = Date.now() - section.lastSyncAttempt;
            if (timeSinceLastSync < SYNC_RATE_LIMIT_MS) {
                console.warn(`[ServiceWorker] Force sync rate limited: ${timeSinceLastSync}ms since last attempt`);
                // Still broadcast current state
                const { patrols, uiRevision, lastError, lastErrorTime } = await store.getScoresForSection(sectionId);
                await clients.sendScoresToClient(client, userId, sectionId, patrols, uiRevision, lastError, lastErrorTime, requestId);
                return;
            }
        }

        // Try to acquire section sync lock
        const lockId = await store.acquireSectionSyncLock(sectionId, 60000);
        if (!lockId) {
            console.log(`[ServiceWorker] Section ${sectionId} sync already in progress (force sync)`);
            // Broadcast current state showing sync in progress
            const { patrols, uiRevision, lastError, lastErrorTime } = await store.getScoresForSection(sectionId);
            await clients.sendScoresToClient(client, userId, sectionId, patrols, uiRevision, lastError, lastErrorTime, requestId);
            return;
        }

        try {
            // Clear permanent errors (retryAfter = -1 â†’ retryAfter = 0)
            const clearedCount = await store.clearPermanentErrors(sectionId);
            console.log(`[ServiceWorker] Force sync cleared ${clearedCount} permanent errors in section ${sectionId}`);

            // Broadcast state after clearing errors
            const { patrols: afterClear, uiRevision: afterClearRevision } = await store.getScoresForSection(sectionId);
            await clients.publishScores(userId, sectionId, afterClear, afterClearRevision);

            // Check authentication
            const server = await requireLoggedInUser(client, userId, requestId);
            if (!server) {
                return;
            }

            // Perform sync using existing syncPendingScores logic
            if (!server.isOffline()) {
                await syncPendingScores(server, store, userId, sectionId);
            }
        } finally {
            // Always release section lock
            await store.releaseSectionSyncLock(sectionId, lockId);

            // Broadcast final state
            const { patrols, uiRevision, lastError, lastErrorTime } = await store.getScoresForSection(sectionId);
            await clients.publishScores(userId, sectionId, patrols, uiRevision, lastError, lastErrorTime);
        }
    } finally {
        store.close();
    }
}
