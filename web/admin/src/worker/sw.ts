/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst } from 'workbox-strategies';
import * as messages from './messages'
import {OsmAdapterApiService} from "./server/server.ts";
import {sendMessage} from "./client.ts";
import {newAuthenticationRequiredMessage, type PatrolsChangeMessage} from "./messages/workerToClient.ts";
import {OpenPatrolPointsStore, Patrol, PatrolPointsStore} from "./store/store.ts";
import type {ScoreDelta} from "./messages";

declare let self: ServiceWorkerGlobalScope;

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Take control of all clients when activated
self.addEventListener('activate', () => {
    self.clients.claim();
});

// Network-first for API calls
registerRoute(
    ({ url }) => url.pathname.startsWith('/api/'),
    new NetworkFirst({
        cacheName: 'api-cache',
    })
);

self.addEventListener('message', (event) => {
//    const client = event.source as Client;
    const message = event.data as messages.ClientMessage;
    switch (message.type) {
        case 'refresh':
            refreshScores(message.sectionId);
            break;
        case 'submit-scores':
            submitScores(message.userId, message.sectionId, message.deltas);
            break;
        default:
            const unrecognized = message as any;
            console.warn(`ServiceWorker: Unexpected message type ${unrecognized.type}`);
    }
});

async function refreshScores(sectionId: number) {
    const server = new OsmAdapterApiService();
    const session = await server.fetchSession();
    if(!session.isAuthenticated) {
        sendMessage(newAuthenticationRequiredMessage(server.getLoginUrl()));
        return;
    }

    const store = await OpenPatrolPointsStore(session.userId);
    const scores = await server.fetchScores(sectionId);
    const newScores = await store.setCanonicalPatrolList(sectionId, scores);
    publishScores(session.userId, sectionId, newScores);
}

/**
 * Add pending score changes to the store and trigger a sync.
 * This is called when the user makes changes in the UI.
 */
async function submitScores(userId: number, sectionId: number, deltas: ScoreDelta[]) {
    // Add pending changes to the store (optimistic update)
    const store: PatrolPointsStore = await OpenPatrolPointsStore(userId);
    for (const delta of deltas) {
        await store.addPendingPoints(sectionId, delta.patrolId, delta.score);
    }

    // Publish the optimistic update immediately to all clients
    const updatedScores = await store.getScoresForSection(sectionId);
    publishScores(userId, sectionId, updatedScores);

    // Now trigger a background sync to commit the changes
    await syncPendingScores(userId, sectionId);
}

/**
 * Sync all pending score changes for a section to the server.
 * This can be called directly for background sync or after submitScores.
 */
async function syncPendingScores(userId: number, sectionId: number) {
    const store: PatrolPointsStore = await OpenPatrolPointsStore(userId);

    // Verify the user is still authenticated
    const server = new OsmAdapterApiService();
    const session = await server.fetchSession();
    if (!session.isAuthenticated || session.userId !== userId) {
        // User is no longer authenticated or has switched accounts
        // The pending changes are preserved in the store under their original userId
        sendMessage(newAuthenticationRequiredMessage(server.getLoginUrl()));
        return;
    }

    // Atomically acquire lock and get pending patrols
    let lockId: string | null = null;
    try {
        const { lockId: acquiredLockId, pending } = await store.acquirePendingForSync(sectionId, 30000);
        lockId = acquiredLockId;

        if (pending.length === 0) {
            console.log(`[ServiceWorker] No pending scores to sync for section ${sectionId}`);
            return;
        }

        // Build the updates array from the pending patrols
        const updates = pending.map(patrol => ({
            patrolId: patrol.patrolId,
            points: patrol.pendingScoreDelta
        }));

        console.log(`[ServiceWorker] Syncing ${updates.length} pending scores for section ${sectionId}`);

        // Submit to server
        const serverResult = await server.updateScores(sectionId, updates);

        // Build a unit of work to process all results atomically
        const uow = store.newUnitOfWork();
        for (const patrol of serverResult) {
            if (patrol.success) {
                uow.setCommittedScore(sectionId, patrol.id, patrol.newScore, patrol.name);
            } else if (patrol.isTemporaryError && patrol.retryAfter) {
                // Temporary error - schedule retry
                const retryDate = new Date(patrol.retryAfter);
                uow.setRetryAfter(sectionId, patrol.id, retryDate, patrol.errorMessage);
            } else {
                // Permanent error - mark as failed
                uow.setError(sectionId, patrol.id, patrol.errorMessage || 'Update failed');
            }
        }
        await uow.commit();
    } catch (e: any) {
        // Catastrophic error (network failure, server error, etc.)
        // Mark all pending entries as failed so the user can see what happened
        await store.markAllPendingAsFailed(sectionId, e.message || 'Failed to sync scores');
    } finally {
        // Always release the lock
        if (lockId) {
            await store.releaseSyncLock(sectionId, lockId);
        }

        // Publish the updated scores to all clients
        const updatedScores = await store.getScoresForSection(sectionId);
        publishScores(userId, sectionId, updatedScores);
    }
}

/** Publish the updated scores to all clients. */
async function publishScores(userId: number, sectionId: number, scores: Patrol[]) {
    const message : PatrolsChangeMessage = {
        type: 'patrols-change',
        userId,
        sectionId,
        scores: scores.map( (s:Patrol):messages.PatrolScore => ({
            id: s.patrolId,
            name: s.patrolName,
            committedScore: s.committedScore,
            pendingScore: s.pendingScoreDelta
        }))
    }
    sendMessage(message);
}
