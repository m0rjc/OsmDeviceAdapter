/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst } from 'workbox-strategies';
import * as messages from '../types/messages'
import {NetworkError, OsmAdapterApiService, type SessionStatus} from "./server/server";
import * as clients from "./client";
import {OpenPatrolPointsStore, PatrolPointsStore, Patrol as StoredPatrol} from "./store/store";
import type {ScoreDelta} from "../types/model";
import {reduceError} from "../types/reduceError";

declare let self: ServiceWorkerGlobalScope;

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Take control of all clients when activated
self.addEventListener('activate', () => {
    self.clients.claim();
});

// Network-first for API calls
registerRoute(
    ({ url }) => url.pathname.startsWith('/api/'),
    new NetworkFirst({
        cacheName: 'api-cache',
    })
);

/**
 * Listen for messages from clients.
 */
self.addEventListener('message', (event) => {
    const client = event.source as Client;
    const message = event.data as messages.ClientMessage;
    switch (message.type) {
        case 'get-profile':
            getProfile(client, message.requestId);
            break;
        case 'refresh':
            refreshScores(client, message.requestId, message.userId, message.sectionId);
            break;
        case 'submit-scores':
            submitScores(client, message.requestId, message.userId, message.sectionId, message.deltas);
            break;
        default:
            const unrecognized = message as any;
            console.warn(`ServiceWorker: Unexpected message type ${unrecognized.type}`);
    }
});

/**
 * Require the specified user to be logged in.
 * Sends message to client if not logged in.
 * @param server
 * @param client
 * @param userId
 * @param requestId - Optional correlation ID from the originating request
 */
async function requireLoggedInUser(server: OsmAdapterApiService, client: Client, userId: number, requestId?: string): Promise<SessionStatus>  {
    const session = await server.fetchSession();
    if(!session.isAuthenticated) {
        client.postMessage(messages.newAuthenticationRequiredMessage(server.getLoginUrl(), requestId));
        return session;
    }
    if (session.userId != userId) {
        client.postMessage(messages.newWrongUserMessage(userId, session.userId));
        return {isAuthenticated: false };
    }
    return session;
}

/**
 * Fetch the user profile from the server and send it to the client.
 * If the user is logged in, then a UserProfileMessage is given.
 * If the user is logged out, then an AuthenticationRequiredMessage is given.
 *
 * All clients will receive a SectionListChangeMessage if the section list has
 * changed. This is published after the UserProfileMessage sent to the calling
 * client. The first client will expect both messages because its call will
 * initialize the section list for the first time. The section list is
 * stored in browser storage until explicitly cleared.
 *
 * @param client - The client requesting the profile
 * @param requestId - Correlation ID to match request with response
 */
export async function getProfile(client: Client, requestId: string) {
    const server = new OsmAdapterApiService();

    try {
        const session = await server.fetchSession();
        if(!session.isAuthenticated) {
            client.postMessage(messages.newAuthenticationRequiredMessage(server.getLoginUrl(), requestId));
            return;
        }

        const store = await OpenPatrolPointsStore(session.userId);
        try {
            const sections = await server.fetchSections()
            const { changed, sectionsListRevision, lastError, lastErrorTime } = await store.setCanonicalSectionList(sections);
            client.postMessage(messages.newUserProfileMessage(
                session.userId,
                session.userName,
                sections,
                sectionsListRevision,
                requestId,
                lastError,
                lastErrorTime
            ));
            if (changed) {
                await clients.sendMessage(messages.newSectionListChangeMessage(session.userId, sections, sectionsListRevision));
            }
        } catch (e) {
            // Store the error in user metadata and bump sections list revision
            const errorMessage = reduceError(e, "Unable to fetch section list from server.");
            const { sectionsListRevision, lastError, lastErrorTime } = await store.setProfileError(errorMessage);

            // Get cached sections (if any) and send with error state
            const sections = await store.getSections();
            client.postMessage(messages.newUserProfileMessage(
                session.userId,
                session.userName,
                sections,
                sectionsListRevision,
                requestId,
                lastError,
                lastErrorTime
            ));
        } finally {
            store.close();
        }
    } catch (e) {
        // fetchSession() failed - we don't have a userId yet, so just send auth required
        client.postMessage(messages.newAuthenticationRequiredMessage(server.getLoginUrl(), requestId));
    }
}

/**
 * Request to refresh the patrol scores from the server.
 * This can also be used to perform the initial load of scores when the UI switches section.
 *
 * The worker will respond asynchronously with a PatrolsChangeMessage (includes requestId).
 * If the server is unreachable, cached data is sent first (with requestId), followed by
 * a ServiceErrorMessage (with requestId) to indicate the refresh failed.
 *
 * If the user is not logged in, then AuthenticationRequiredMessage is given (with requestId).
 * If the wrong user is logged in, then WrongUserMessage is given.
 *
 * @param client - The client requesting the refresh
 * @param requestId - Correlation ID to match request with response
 * @param userId - Expected user ID
 * @param sectionId - Section ID to refresh
 */
export async function refreshScores(client: Client, requestId: string, userId: number, sectionId: number) {
    const server = new OsmAdapterApiService();
    const session = await requireLoggedInUser(server, client, userId, requestId);
    if(!session.isAuthenticated) {
        return;
    }

    const store = await OpenPatrolPointsStore(userId);
    try {
        const scores = await server.fetchScores(sectionId);
        const { patrols, uiRevision, lastError, lastErrorTime } = await store.setCanonicalPatrolList(sectionId, scores);
        // Send successful response with requestId to the specific client (error state cleared)
        console.debug(`[ServiceWorker] Refreshing scores for section ${sectionId} succeeded`);
        clients.sendScoresToClient(client, userId, sectionId, patrols, uiRevision, lastError, lastErrorTime, requestId);
    } catch (e) {
        // Store the error on the section record and bump its UI revision
        const errorMessage = reduceError(e, "Unable to refresh patrol scores from server.");
        await store.setSectionError(sectionId, errorMessage);

        // Get the cached data with the new error state and send it
        console.warn(`[ServiceWorker] Refreshing scores for section ${sectionId} failed. Trying cached data:`);
        const { patrols, uiRevision, lastError, lastErrorTime } = await store.getScoresForSection(sectionId);
        clients.sendScoresToClient(client, userId, sectionId, patrols, uiRevision, lastError, lastErrorTime, requestId);
    } finally {
        store.close();
    }
}


/**
 * Add pending score changes to the store and trigger a sync.
 * This is called when the user makes changes in the UI.
 *
 * @param client - The client submitting the scores
 * @param requestId - Correlation ID to match request with response
 * @param userId - User ID
 * @param sectionId - Section ID
 * @param deltas - Score changes to apply
 */
export async function submitScores(client: Client, requestId: string, userId: number, sectionId: number, deltas: ScoreDelta[]) {
    const store: PatrolPointsStore = await OpenPatrolPointsStore(userId);
    try {
        // Add pending changes to the store.
        // This optimistic update ensures that user intent is saved even if they have lost
        // authentication. This allows the user to recover by logging in again.
        for (const delta of deltas) {
            await store.addPendingPoints(sectionId, delta.patrolId, delta.score);
        }

        // Publish the optimistic update immediately to all clients
        // Note: This is an unsolicited broadcast, so no requestId
        const { patrols, uiRevision, lastError, lastErrorTime } = await store.getScoresForSection(sectionId);
        await clients.publishScores(userId, sectionId, patrols, uiRevision, lastError, lastErrorTime);

        // Only perform the sync if the user is still logged in.
        // If the user is not logged in, then requireLoggedInUser will send a message to the client
        // requesting them to log in again.
        const server = new OsmAdapterApiService();
        if (! (await requireLoggedInUser(server, client, userId, requestId)).isAuthenticated) {
            return;
        }

        // Perform a sync process for this {user,section} to commit the changes to the server.
        if(!server.isOffline()) {
            await syncPendingScores(server, store, userId, sectionId);
        }
    } finally {
        store.close();
    }
}

/**
 * Sync all pending score changes for a {user,section} to the server.
 * The server and store must be tied to the same user.
 */
async function syncPendingScores(server: OsmAdapterApiService, store: PatrolPointsStore, userId: number, sectionId: number) {
    // Atomically acquire lock and get pending patrols
    let lockId: string | null = null;
    let hasChanges: boolean = false;
    try {
        const {lockId: acquiredLockId, pending} = await store.acquirePendingForSync(sectionId, 30000);
        lockId = acquiredLockId;

        if (pending.length === 0) {
            console.log(`[ServiceWorker] No pending scores to sync for section ${sectionId}`);
            return // via finally;
        }

        // Build the updates array from the pending patrols
        const updates = pending.map((patrol : StoredPatrol):ScoreDelta => ({
            patrolId: patrol.patrolId,
            score: patrol.pendingScoreDelta
        }));
        hasChanges = true;

        console.log(`[ServiceWorker] Syncing ${updates.length} pending scores for section ${sectionId}`);

        // Submit to server
        const serverResult = await server.updateScores(sectionId, updates);

        // Build a unit of work to process all results atomically
        const uow = store.newUnitOfWork();
        for (const patrol of serverResult) {
            if (patrol.success) {
                uow.setCommittedScore(sectionId, patrol.id, patrol.newScore, patrol.name);
                continue;
            }

            // Type narrow: patrol is now a failure result (use type assertion as workaround)
            const failedPatrol = patrol as any;
            if (failedPatrol.isTemporaryError && failedPatrol.retryAfter) {
                // Temporary error - schedule retry
                const retryDate = new Date(failedPatrol.retryAfter);
                uow.setRetryAfter(sectionId, failedPatrol.id, retryDate, failedPatrol.errorMessage);
            } else {
                // Permanent error - mark as failed
                uow.setError(sectionId, failedPatrol.id, failedPatrol.errorMessage || 'Update failed');
            }
        }
        await uow.commit();
    } catch (e: any) {
        // Catastrophic error (network failure, server error, etc.)
        if(e instanceof NetworkError) {
            console.warn(`[ServiceWorker] Network error syncing scores for section ${sectionId}:`, e.cause);
        } else {
            // Mark all pending entries as failed so the user can see what happened
            await store.markAllPendingAsFailed(sectionId, e.message || 'Failed to sync scores');
            console.error(`[ServiceWorker] Error in syncPendingScores for section ${sectionId}:`, e);
        }
    } finally {
        // Always release the lock
        if (lockId) {
            await store.releaseSyncLock(sectionId, lockId);
        }

        // If I did anything, then publish the updated scores to all clients
        if (hasChanges) {
            const { patrols, uiRevision, lastError, lastErrorTime } = await store.getScoresForSection(sectionId);
            await clients.publishScores(userId, sectionId, patrols, uiRevision, lastError, lastErrorTime);
        }
    }
}
